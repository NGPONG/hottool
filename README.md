# hot toolset
c++ hotfix, find symbol addr, read and write process memory...

### 1 hotfix
hotfix process

### 2 hot find
find symbol addr and got.plt addr

### 流程

1. 初始化hook环境
  1.1. 附加到远程进程
    * ptrach(ATTACH) 附加到进程
    * waitpid 等待进程挂起
  1.2. 查询进程的第一个拥有可执行属性的libc段
    * 查询 /proc/<pid>/maps 文件
  1.3. 跨地址空间读取远程进程的内存数据，读取的位置为libc段(上一步)往后偏移8byte的长度为8byte数据，作为一个备份
    * process_vm_readv
    * /proc/<pid>/mem 和 pread
    * ptrace(PTRACE_PEEKTEXT)
  1.4. libc段往后偏移8byte的位置写入syscall指令并执行mmap函数，以创建一个匿名映射的内存空间。该空间充当一个用户自定义的调用栈，在后面的某些函数执行时需要依赖这个用户栈来完成
    * 为了避免可能写坏了库在前8byte的初始化、版本控制的一些信息，抑或是为了避免破坏对齐要求，所以选择在libc段向后偏移8byte的位置作为指令写入空间
    * 写入指令的同时修改$rip为指令写入开始时的内存位置，并调用 ptrace(PTRACE_CONT) 恢复(在1.1暂停)程序执行
    * 程序恢复执行后继续使用waitpid等待进程的系统调用结束，并依据信号来判断执行是否产生异常
    * ptrace(PTRACE_GETREGS) 和 ptrace(PTRACE_SETREGS) 来完成寄存器的调用前的备份和调用后的还原逻辑
    * 写入并执行完毕后我们需要使用 1.3. 备份的数据还原被写入的内存空间，来保证程序的状态在执行完unsafe代码后能够保持前后的一致
2. 读取远程进程中需要被热更的函数的地址还有该函数对应PLT索引的地址
  * 需要注意的是，源代码中是基于ELF文件的内容去处理的，也就是说没有下沉到ELF文件映射到内存中的内容本身，因为操作系统和动态链接器并不一定会保证我们需要访问的段一定会原封不动的映射到地址空间中，特别是一些debug作用的段映射到内存是没有意义的。另外一点，其内存布局可能会因为各种原因（比如地址重定位、页对齐）与原始文件布局有所不同。特别是，由于动态链接的需要，某些部分可能会被移动或重新定位。
  * 作者依据条件选择了两个不同的调用去处理，一个是直接通过读远程进程对应ELF文件中的数据进行索引，另外一个则是通过查询远程进程的地址空间来索引，但是实际的逻辑是类似的
  * 既然是跨进程动态修改，那么我们还是要以目标进程本身的内存空间作为基础去实现逻辑，比如查询 ELF 头部的信息、查询需要的内存段(.dynsym, .dynstr, .plt, .rela.plt)，匹配符号的名字等等。但是不管怎么说都需要对ELF文件本身的内存布局还有动态链接器的原理需要相当熟悉。
  * libc库已经为我们提供了正确的结构如：Elf64_Ehdr, Elf64_Shdr, Elf64_Sym, Elf64_Phdr, Elf64_Rela。也就是说我们只需要在正确的位置读取内存并初始化相关的struct即可完成正确的调用。
3. 跨进程调用dlopen以打开准备好的so文件
  * 这里使用了在初始化环境时构造的用户自定义的栈来调用函数，可能是为了避免栈空间被破坏；而对于某些系统调用不使用栈的原因可能是因为寄存器传输已满足要求
  * 关于查找dlopen函数地址的逻辑其实和第二条类似，但是我们需要在libc内存段中去查询函数地址
  * 在调用前我们还需要跨进程调用mmap函数并作为dlopen调用时的字符串(so文件的地址)传输
4. 重复第2节的逻辑，指示我们要查询的是dlopen后的新函数的地址与PLT索引，以便后续逻辑的替换
5. 执行跳转替换
  * 如果是不需要依赖 PLT/GOT 跳转的操作，则直接覆盖函数首地址的N个字节的内容为新函数的跳转地址；但是源码中实现的不合理，没有考虑对齐要求，且覆盖了原函数中可能某些比较重要的指令
  * 如果需要依赖 PLT/GOT 的操作，则覆盖 PLT 表中的内容为新函数的地址

